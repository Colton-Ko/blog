---
// Search modal component - Spotlight-style
import { getDefaultLanguage } from "../../config.language";
import { searchModalTranslations } from "./SearchModalTranslations";

const DEFAULT_LANG = getDefaultLanguage();
const allTranslations = searchModalTranslations;
const translations = searchModalTranslations[DEFAULT_LANG];
---

<div
  id="search-modal"
  class="search-modal"
  style="display: none;"
  data-translations={JSON.stringify(allTranslations)}
>
  <div class="search-backdrop"></div>
  <div id="search-container" class="search-container">
    <div class="search-header" id="search-drag-handle">
      <input
        type="text"
        id="search-input"
        class="search-input"
        placeholder={translations.placeholder}
        autocomplete="off"
        spellcheck="false"
      />
      <button
        id="search-close"
        class="search-close"
        aria-label={translations.closeLabel}
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    </div>
    <div class="search-results" id="search-results">
      <!-- Results will be displayed here -->
      <div id="search-empty" class="search-empty">
        {translations.emptyState}
      </div>
    </div>
  </div>
</div>

<script>
  import { animate } from "motion";

  function initSearchModal() {
    const modal = document.getElementById("search-modal");
    const container = document.getElementById("search-container");
    const backdrop = document.querySelector(".search-backdrop");
    const closeBtn = document.getElementById("search-close");
    const input = document.getElementById(
      "search-input",
    ) as HTMLInputElement | null;
    const dragHandle = document.getElementById("search-drag-handle");
    const emptyDiv = document.getElementById("search-empty");
    const resultsContainer = document.getElementById("search-results");

    if (!modal || !container) {
      return;
    }

    // Get translations from data attribute
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let allTranslations: Record<string, any> = {};
    try {
      allTranslations = JSON.parse(modal.dataset.translations || "{}");
    } catch (e) {
      console.error("Failed to parse translations:", e);
    }

    // Search state
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let searchIndex: any[] = [];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let fuse: any = null;

    // Load search index
    async function loadSearchIndex() {
      try {
        // Load Fuse.js from CDN if not already loaded
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (typeof (window as any).Fuse === "undefined") {
          const script = document.createElement("script");
          script.src =
            "https://cdn.jsdelivr.net/npm/fuse.js@7.0.0/dist/fuse.min.js";
          await new Promise((resolve, reject) => {
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
          });
        }

        const response = await fetch("/api/search-index.json");
        searchIndex = await response.json();

        // Initialize Fuse.js
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        fuse = new (window as any).Fuse(searchIndex, {
          keys: ["title", "content"],
          threshold: 0.3,
          includeScore: true,
          ignoreLocation: true,
        });
      } catch (error) {
        console.error("Failed to load search index:", error);
      }
    }

    // Keyboard navigation state
    let selectedIndex = 0;

    // Perform search
    function performSearch(query: string) {
      if (!query || !fuse) {
        // Show empty state
        if (emptyDiv) emptyDiv.style.display = "block";
        const resultItems = resultsContainer?.querySelectorAll(
          ".search-result-item",
        );
        resultItems?.forEach((item) => item.remove());
        return;
      }

      // Hide empty state
      if (emptyDiv) emptyDiv.style.display = "none";

      // Get current language
      const currentLang = localStorage.getItem("lang") || "us";

      // Search and FILTER by current language
      const allResults = fuse
        .search(query)
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        .filter((r: any) => r.item.lang === currentLang);

      // Hierarchical Filtering: Group by slug (Post) and keep only highest level matches
      const resultsByPost = {};

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      allResults.forEach((result: any) => {
        const slug = result.item.slug;
        if (!resultsByPost[slug]) {
          resultsByPost[slug] = [];
        }
        resultsByPost[slug].push(result);
      });

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const filteredResults: any[] = [];

      Object.values(resultsByPost).forEach((postResults) => {
        // Find minimum heading level (0 = Title, 1 = H1, etc.)
        const minLevel = Math.min(
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          ...postResults.map((r: any) =>
            r.item.headingLevel !== undefined ? r.item.headingLevel : 999,
          ),
        );

        // Keep only results with that minimum level
        const bestMatches = postResults.filter(
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (r: any) =>
            (r.item.headingLevel !== undefined ? r.item.headingLevel : 999) ===
            minLevel,
        );
        filteredResults.push(...bestMatches);
      });

      // Sort by score (Fuse.js score) and take top 8
      const finalResults = filteredResults
        .sort((a, b) => a.score - b.score)
        .slice(0, 8);

      // Clear previous results
      const oldResults = resultsContainer?.querySelectorAll(
        ".search-result-item",
      );
      oldResults?.forEach((item) => item.remove());

      // Reset selection
      selectedIndex = 0;

      // Get current language translations
      const currentLangForDisplay = localStorage.getItem("lang") || "us";
      const t = allTranslations[currentLangForDisplay] || allTranslations.us;

      // Display results
      if (finalResults.length === 0) {
        const noResults = document.createElement("div");
        noResults.className = "search-result-item no-results";
        noResults.textContent = t.noResults;
        resultsContainer?.appendChild(noResults);
      } else {
        finalResults.forEach((result, index) => {
          const item = document.createElement("a");
          item.className = "search-result-item";
          if (index === 0) item.classList.add("selected"); // Select first item by default
          item.href = result.item.url;
          item.dataset.index = index.toString();

          // Close search on click
          item.addEventListener("click", () => {
            closeSearch();
          });

          // Update selection on hover
          item.addEventListener("mouseenter", () => {
            updateSelection(index);
          });

          // Create premium card structure
          const header = document.createElement("div");
          header.className = "result-header";

          const title = document.createElement("div");
          title.className = "result-title";

          // Show heading content if it's a heading, otherwise show title
          if (result.item.headingLevel > 0) {
            title.textContent = result.item.content;
          } else {
            title.textContent = result.item.title;
          }

          header.appendChild(title);

          const preview = document.createElement("div");
          preview.className = "result-preview";
          // Get a preview snippet
          const content = result.item.content;
          const previewText =
            content.length > 120 ? content.substring(0, 120) + "..." : content;
          preview.textContent = previewText;

          item.appendChild(header);
          item.appendChild(preview);
          resultsContainer?.appendChild(item);
        });
      }
    }

    // Update visual selection
    function updateSelection(index: number) {
      const items = resultsContainer?.querySelectorAll(
        ".search-result-item:not(.no-results)",
      );
      if (!items || items.length === 0) return;

      // Clamp index
      if (index < 0) index = 0;
      if (index >= items.length) index = items.length - 1;

      selectedIndex = index;

      items.forEach((item, i) => {
        if (i === selectedIndex) {
          item.classList.add("selected");
          // Ensure visible
          item.scrollIntoView({ block: "nearest" });
        } else {
          item.classList.remove("selected");
        }
      });
    }

    // Multi-language placeholders and empty state text
    // Using allTranslations passed via define:vars

    // Update placeholder and empty text based on language
    function updatePlaceholder() {
      const currentLang = localStorage.getItem("lang") || "us";
      const t = allTranslations[currentLang] || allTranslations.us;

      if (input) {
        input.placeholder = t.placeholder;
      }
      if (emptyDiv) {
        emptyDiv.textContent = t.emptyState;
      }
    }

    let isDragging = false;
    let currentX: number;
    let currentY: number;
    let initialX: number;
    let initialY: number;
    let xOffset = 0;
    let yOffset = 0;

    // Open modal
    function openSearch() {
      updatePlaceholder();
      if (!modal) return;
      modal.style.display = "flex";

      // Animate in
      if (!container) return;
      animate(
        container,
        { transform: ["scale(0.95)", "scale(1)"], opacity: [0, 1] },
        { duration: 0.2, easing: "ease-out" },
      );

      if (backdrop) {
        animate(backdrop, { opacity: [0, 1] }, { duration: 0.2 });
      }

      input?.focus();
      // Re-run search if there is existing input (persistence)
      if (input && input.value) {
        performSearch(input.value);
        input.select(); // Select all text
      }

      // Reset position
      xOffset = 0;
      yOffset = 0;
      if (container) {
        container.style.transform = "translate(0, 0) scale(1)";
      }
    }

    // Close modal
    function closeSearch() {
      // Animate out
      if (!modal || !container) return;
      const containerAnim = animate(
        container,
        { transform: ["scale(1)", "scale(0.95)"], opacity: [1, 0] },
        { duration: 0.15, easing: "ease-in" },
      );

      const backdropAnim = backdrop
        ? animate(backdrop, { opacity: 0 }, { duration: 0.15 })
        : null;

      Promise.all([containerAnim.finished, backdropAnim?.finished]).then(() => {
        modal.style.display = "none";
      });
    }

    // Drag functionality
    function dragStart(e: MouseEvent | TouchEvent) {
      if (e.type === "touchstart") {
        initialX = (e as TouchEvent).touches[0].clientX - xOffset;
        initialY = (e as TouchEvent).touches[0].clientY - yOffset;
      } else {
        initialX = (e as MouseEvent).clientX - xOffset;
        initialY = (e as MouseEvent).clientY - yOffset;
      }

      if (
        e.target === dragHandle ||
        (dragHandle && dragHandle.contains(e.target as Node))
      ) {
        isDragging = true;
        if (container) container.style.cursor = "grabbing";
      }
    }

    function dragEnd() {
      initialX = currentX;
      initialY = currentY;
      isDragging = false;
      if (container) container.style.cursor = "default";
    }

    function drag(e: MouseEvent | TouchEvent) {
      if (isDragging) {
        e.preventDefault();

        if (e.type === "touchmove") {
          currentX = (e as TouchEvent).touches[0].clientX - initialX;
          currentY = (e as TouchEvent).touches[0].clientY - initialY;
        } else {
          currentX = (e as MouseEvent).clientX - initialX;
          currentY = (e as MouseEvent).clientY - initialY;
        }

        xOffset = currentX;
        yOffset = currentY;

        if (container) {
          container.style.transform = `translate(${currentX}px, ${currentY}px)`;
        }
      }
    }

    // Event listeners
    window.addEventListener("open-search", openSearch);
    closeBtn?.addEventListener("click", closeSearch);
    backdrop?.addEventListener("click", closeSearch);

    // Close on Escape
    document.addEventListener("keydown", (e) => {
      // Ctrl+K or Cmd+K to toggle search
      if ((e.ctrlKey || e.metaKey) && e.key === "k") {
        e.preventDefault();
        if (modal.style.display === "flex") {
          closeSearch();
        } else {
          openSearch();
        }
      }

      // Escape to close
      if (e.key === "Escape" && modal.style.display === "flex") {
        closeSearch();
      }

      // Keyboard Navigation
      if (modal.style.display === "flex") {
        const items = resultsContainer?.querySelectorAll(
          ".search-result-item:not(.no-results)",
        );
        if (items && items.length > 0) {
          if (e.key === "ArrowDown") {
            e.preventDefault();
            updateSelection(selectedIndex + 1);
          } else if (e.key === "ArrowUp") {
            e.preventDefault();
            updateSelection(selectedIndex - 1);
          } else if (e.key === "Enter") {
            e.preventDefault();
            const selectedItem = items[selectedIndex];
            if (selectedItem) {
              (selectedItem as HTMLAnchorElement).click();
            }
          }
        }
      }
    });

    // Drag events
    dragHandle?.addEventListener("mousedown", dragStart);
    document.addEventListener("mousemove", drag);
    document.addEventListener("mouseup", dragEnd);

    dragHandle?.addEventListener("touchstart", dragStart);
    document.addEventListener("touchmove", drag);
    document.addEventListener("touchend", dragEnd);

    // Update placeholder on language change
    window.addEventListener("language-change", updatePlaceholder);

    // Search on input
    input?.addEventListener("input", (e) => {
      if (e.target) {
        performSearch((e.target as HTMLInputElement).value);
      }
    });

    // Load search index
    loadSearchIndex();

    // Set initial placeholder
    updatePlaceholder();
  }

  document.addEventListener("astro:page-load", initSearchModal);
</script>

<style>
  .search-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 9999;
    align-items: center;
    justify-content: center;
  }

  .search-backdrop {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(3px);
    -webkit-backdrop-filter: blur(8px);
    opacity: 0;
  }

  .search-container {
    position: relative;
    width: 90%;
    max-width: 600px;
    background: var(--color-bg-white);
    border-radius: var(--radius-2xl);
    box-shadow:
      0 20px 25px -5px rgba(0, 0, 0, 0.1),
      0 10px 10px -5px rgba(0, 0, 0, 0.04);
    overflow: hidden;
    transform: scale(0.95);
    opacity: 0;
  }

  .search-header {
    display: flex;
    align-items: center;
    padding: var(--spacing-md);
    border-bottom: 1px solid var(--color-gray-200);
    gap: var(--spacing-sm);
    cursor: grab;
    user-select: none;
  }

  .search-input {
    flex: 1;
    border: none;
    outline: none;
    font-size: 1.125rem;
    padding: var(--spacing-sm);
    background: transparent;
  }

  .search-input::placeholder {
    color: var(--color-gray-400);
  }

  .search-close {
    background: none;
    border: none;
    cursor: pointer;
    padding: var(--spacing-sm);
    color: var(--color-gray-500);
    border-radius: var(--radius-md);
    transition: all 0s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .search-close:hover {
    background-color: var(--color-gray-100);
    color: var(--color-gray-700);
  }

  .search-results {
    max-height: 400px;
    overflow-y: auto;
    padding: var(--spacing-md-sm);
  }

  .search-empty,
  :global(.no-results) {
    text-align: center;
    color: var(--color-gray-400);
    padding: var(--spacing-xl);
    font-size: 0.875rem;
  }

  /* Dynamic elements need :global() because they are created by JS */
  :global(.search-result-item) {
    display: block;
    padding: var(--spacing-md-sm);
    margin-bottom: var(--spacing-sm);
    border-radius: var(--radius-xl);
    cursor: pointer;
    text-decoration: none;
    color: inherit;
    transition: all var(--transition-base) cubic-bezier(0.4, 0, 0.2, 1);
    border: 1px solid transparent;
    background-color: var(--color-bg-card);
  }

  /* Hover state - Light Gray */
  :global(.search-result-item:hover) {
    background-color: var(--color-gray-100);
    border-color: var(--color-border-light);
    transform: translateY(-1px);
  }

  /* Selected state (Keyboard/Active) - Blue */
  :global(.search-result-item.selected) {
    background-color: var(--color-blue-50);
    border-color: var(--color-blue-200);
    transform: translateY(-1px);
  }

  :global(.search-result-item:last-child) {
    margin-bottom: var(--spacing-md-sm);
  }

  :global(.result-header) {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--spacing-sm);
  }

  :global(.result-title) {
    font-weight: 600;
    font-size: 1.05rem;
    color: var(--color-gray-900);
    letter-spacing: -0.01em;
  }

  :global(.lang-badge) {
    font-size: 0.75rem;
    padding: 0.15rem var(--spacing-sm);
    border-radius: 9999px;
    background-color: var(--color-gray-100);
    color: var(--color-gray-600);
    font-weight: 500;
    border: 1px solid var(--color-gray-200);
    white-space: nowrap;
    margin-left: var(--spacing-md-sm);
  }

  :global(.result-preview) {
    font-size: 0.9rem;
    color: var(--color-gray-500);
    line-height: 1.5;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  /* Hide on mobile */
  @media (max-width: 767px) {
    .search-modal {
      display: none !important;
    }
  }
</style>
